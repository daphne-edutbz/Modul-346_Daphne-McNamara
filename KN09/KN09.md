# KN09: Automation



## A) Automatisierung mit Command Line Interface (CLI) (30%)

### Einrichtung AWS CLI

1. AWS CLI Version prüfen:

``` powershell
aws --version
```

Ergebnis:

``aws-cli/2.33.2 Python/3.13.11 Windows/11 exe/AMD64``

2. AWS CLI konfigurieren:

 ``` powershell
aws configure
AWS Access Key ID: ASIAR3OF5Z5ZI5FRRUEP
AWS Secret Access Key: H0LFE1IPYSU6/MINu4b/LbOC/UDPiyKv/BgZGwGD
AWS Session Token: IQoJb3JpZ2luX2VjEM3
Default region name: us-east-1
Default output format: json
```

Ergebnis: CLI erfolgreich eingerichtet, JSON-Ausgabe konfiguriert, Zugriff auf die Schulungsumgebung möglich


### Instanzen durch AWS CLI

#### 1. Status der bestehenden Instanzen prüfen

Befehl:
```powershell
aws ec2 describe-instances
```

Ausgabe: zeigt alle laufenden Instanzen mit IP-Adressen, State, Security Group, Subnet etc. (als JSON, wie im vorherigen Befehl definiert)

<img width="952" height="557" alt="awsInstancesDescirbe" src="https://github.com/user-attachments/assets/014743cb-e25d-4b1f-82c4-5b8f55af3a31" />


#### 2. Starten und Stoppen einer Instanz

##### Starten

Beispiel Instanz-ID:
`i-070905f552cd35514`

Befehl:

``` powershell
aws ec2 stop-instances --instance-ids i-070905f552cd35514
```

<img width="616" height="278" alt="instanzStoppen" src="https://github.com/user-attachments/assets/27c8e9d6-35e1-454d-9ac9-8cd5939625bd" />

In EC2 sieht man dann:
<img width="775" height="236" alt="stoppedInstance" src="https://github.com/user-attachments/assets/aa769c35-5b6c-4ae3-86eb-df70e651de37" />


##### Stoppen

Befehl:

```powershell
aws ec2 start-instances --instance-ids i-04f1c4d66a1cfda38
```

<img width="805" height="301" alt="instanzStarten" src="https://github.com/user-attachments/assets/a1640cec-2e93-4d63-bd7f-ce8a4905e7c8" />



In EC2 sieht man dann:
<img width="767" height="227" alt="startedInstance" src="https://github.com/user-attachments/assets/2699fefb-508b-4ace-87ad-c5ff784c86ac" />


#### 3. Neue Instanz erstellen (Datenbank-Server mit Cloud-Init)

Cloud-init Datei: `cloud-init-db.yaml` 
- Installiert MariaDB
- Konfiguriert DB, User, Passwort
- Startet MariaDB und öffnet Port 3306


CLI-Befehl:

``` Powershell
aws ec2 run-instances `
  --image-id ami-0030e4319cbf4dbf2 `
  --instance-type t2.micro `
  --key-name Daphne1 `
  --security-group-ids sg-048720ece676513b2 `
  --subnet-id subnet-0a5cdc55 `
  --user-data file://C:/Projects/GitHub/Modul-346_Daphne-McNamara/KN09/cloud-init-db.yaml `
  --tag-specifications "ResourceType=instance,Tags=[{Key=Name,Value=KN09-DB-CLI}]"
```

Ergebnis:
- Neue Instanz KN09-DB-CLI gestartet
- Public IP: 54.87.140.8
- MariaDB installiert und läuft

<img width="953" height="520" alt="newInstance" src="https://github.com/user-attachments/assets/2407b349-c7f9-447a-acc3-145feebe623f" />

<img width="779" height="290" alt="EC2newInstance" src="https://github.com/user-attachments/assets/a4eaf87a-2a92-44ea-a141-91e875b7587f" />

<img width="744" height="375" alt="EC2newInstanceDetails" src="https://github.com/user-attachments/assets/7573f39e-39ce-419c-b577-ee51c0deb2eb" />



#### 4. Funktionalität testen

Befehl:
``` powershell
telnet 54.87.140.8 3306
```

<img width="596" height="176" alt="Telnet" src="https://github.com/user-attachments/assets/64c1a0cf-87e9-433b-89f9-b41f2ea5c07a" />



TCP Test:



<img width="480" height="149" alt="TCPTest" src="https://github.com/user-attachments/assets/70c60e5f-874f-4590-9ed9-146284cea988" />




### CLI-Commands KN05


#### 1. VPC erstellen
```powershell
aws ec2 create-vpc \
--cidr-block 10.0.0.0/16 \
--tag-specifications ResourceType=vpc,Tags=[{Key=Name,Value=vpc-kn05}]
```


#### 2. Subnetz erstellen
```powershell
aws ec2 create-subnet \
--vpc-id vpc-EXAMPLE \
--cidr-block 10.0.1.0/24 \
--tag-specifications ResourceType=subnet,Tags=[{Key=Name,Value=sub-kn04}]
```


#### 3. Security Group erstellen


```powershell
aws ec2 create-security-group \
--group-name SG-Webserver \
--description "something" \
--vpc-id vpc-EXAMPLE

aws ec2 create-security-group \
--group-name SG-Database \
--description "something 2.0" \
--vpc-id vpc-EXAMPLE
```


#### 4. Inbound-Rules setzen
```powershell
aws ec2 authorize-security-group-ingress \
--group-id sg-WEB-EXAMPLE --protocol tcp --port 80 --cidr 0.0.0.0/0

aws ec2 authorize-security-group-ingress \
--group-id sg-WEB-EXAMPLE --protocol tcp --port 443 --cidr 0.0.0.0/0

aws ec2 authorize-security-group-ingress \
--group-id sg-WEB-EXAMPLE --protocol tcp --port 22 --cidr 0.0.0.0/0

aws ec2 authorize-security-group-ingress \
--group-id sg-DB-EXAMPLE --protocol tcp --port 3306 --cidr 10.0.2.0/24
```


#### 5. Elastic IP für Webserver
```powershell
aws ec2 allocate-address \
--domain vpc \
--tag-specifications ResourceType=elastic-ip,Tags=[{Key=Name,Value=ip-web}]
```



#### 6. Netzwerkinterface erstellen
```powershell
aws ec2 create-network-interface \
--subnet-id subnet-KN05-EXAMPLE \
--private-ip-address 10.0.2.10 \
--groups sg-WEB-EXAMPLE \
--tag-specifications ResourceType=network-interface,Tags=[{Key=Name,Value=eni-web-kn05}]
```




#### 7. Instanze erstellen
```powershell
aws ec2 run-instances \
--image-id ami-EXAMPLE \
--instance-type t2.micro \
--network-interfaces NetworkInterfaceId=eni-web-kn05,DeviceIndex=0 \
--tag-specifications ResourceType=instance,Tags=[{Key=Name,Value=web-kn05}]
```



#### 8. Elastic IP einer Instanz zuweisen
```powershell
aws ec2 associate-address \
--allocation-id eipalloc-EXAMPLE \
--network-interface-id eni-web-kn05
```



#### 9. Instanz stoppen
```powershell
aws ec2 stop-instances --instance-ids i-WEB-EXAMPLE i-DB-EXAMPLE
```


### Automatisierung

**Was ist notwendig für die Automatisierung und wie geht man vor?**

Für die Automatisierung mit der AWS CLI reicht es nicht aus, die einzelnen Befehle einfach nacheinander auszuführen. Cloud-Ressourcen besitzen untereinander Abhängigkeiten, zum Beispiel benötigt eine EC2-Instanz ein vorhandenes Subnetz, eine Security Group und gegebenenfalls eine Elastic IP.

Zusätzlich sind viele benötigte Referenzen wie Resource-IDs erst nach der Erstellung bekannt und müssen zwischengespeichert oder an nachfolgende Befehle übergeben werden. Ebenso müssen Wartezeiten, Fehlerbehandlungen und eine korrekte Reihenfolge der Befehle berücksichtigt werden.

Für eine zuverlässige Automatisierung ist es daher notwendig, mit Skripten, Variablen und Kontrolllogik zu arbeiten, um die Ausführung reproduzierbar und idempotent zu gestalten. Alternativ können deklarative Werkzeuge wie Terraform eingesetzt werden, welche Abhängigkeiten automatisch auflösen und die Infrastruktur konsistent und wiederholbar erstellen.




## B) Terraform (70%)

### Terraform einrichten

#### 1. Terraform Installation & Version

``` powershell
terraform version
```

<img width="621" height="194" alt="terraformVersionAndInit" src="https://github.com/user-attachments/assets/01b418ad-9663-4496-95a2-f5bd87f0ad16" />


<img width="307" height="53" alt="terraformVersion" src="https://github.com/user-attachments/assets/82beb063-47ab-4681-ad7b-a18a4d412470" />

#### 2. Terraform initialisierung

``` powershell
terraform init
```

<img width="697" height="306" alt="terraformInit" src="https://github.com/user-attachments/assets/b8b3fb21-263f-4704-8b51-9ae6a5d776a9" />

-> Terraform lädt hier den AWS Provider und initialisiert das Projekt.


#### 3. Terraform Plan

``` powershell
terraform plan
```

<img width="938" height="518" alt="terraformPlan1" src="https://github.com/user-attachments/assets/fd3d7621-df07-44b9-88f8-d30e4630b212" />


<img width="941" height="527" alt="terraformPlan2" src="https://github.com/user-attachments/assets/f1b9edd8-6b8d-46be-9525-97c8f907b7d5" />



-> Terraform zeigt, welche Ressourcen erstellt werden (EC2 + Security Group)


#### 4. Terraform Apply

``` powershell
terraform apply
```

bestätigen mit:
``` powershell
yes
```

<img width="941" height="530" alt="terraformApply1" src="https://github.com/user-attachments/assets/7ff7ab00-7827-4d3d-968d-999e59d063fa" />

<img width="617" height="520" alt="terraformApply2" src="https://github.com/user-attachments/assets/6c4036a5-4add-4e3f-b0e2-b6ff8921abb6" />


#### Instanz auf EC2:

<img width="764" height="380" alt="terraformInstanceDetails" src="https://github.com/user-attachments/assets/74c5d6cb-cc92-4c7f-bbdc-abe86b38c6f1" />


### Funktionstest

``` powershell
telnet <PUBLIC-IP> 3306
```
`<PUBLIC-IP>` in unserem Fall = `3.93.164.250`


<img width="721" height="200" alt="terraformTelnet" src="https://github.com/user-attachments/assets/d3327dfb-2afa-4547-a86e-fd5ae91c3407" />



### Warum ist bei Terraform weniger Automatisierungslogik nötig als bei CLI?

Bei der AWS CLI müssen Abhängigkeiten manuell aufgelöst werden. Ressourcen müssen in der richtigen Reihenfolge erstellt werden und IDs müssen zwischengespeichert werden.
Terraform arbeitet deklarativ. Abhängigkeiten werden automatisch erkannt und korrekt aufgelöst. Terraform stellt sicher, dass die gewünschte Infrastruktur reproduzierbar und idempotent erstellt wird.
